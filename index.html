<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="icon" type="image/png" href="rabbit.png" />
    <link rel="apple-touch-icon" href="rabbit.png" />

    <title>RABBIT HOLE</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: black;
        color: white;
      }
      #form-container {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        z-index: 10;
        width: 100%;
        padding: 20px;
        box-sizing: border-box;
      }
      input,
      button {
        padding: 10px;
        font-size: 24px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
      }
      input {
        width: 100%;
      }
      button {
        cursor: pointer;
        background-color: #444;
        color: white;
      }
      .hidden {
        display: none;
      }
      #pages {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        overflow-y: auto;
        scroll-snap-type: y mandatory;
      }
      .page {
        height: 100vh;
        padding: 20px;
        box-sizing: border-box;
        scroll-snap-align: start;
        white-space: pre-wrap;

        /* Base typography (what you want to reset to for each new page) */
        font-size: 20px;
        line-height: 1.35;
      }
      .small {
        opacity: 0.75;
        font-size: 14px;
        margin-top: 10px;
      }
    </style>
  </head>

  <body>
    <div id="form-container">
      <input type="password" id="apiKey" placeholder="Enter your OpenAI API key" />
      <input type="text" id="subjectInput" placeholder="Enter a starting subject" />
      <button id="okButton">OK</button>
      <img
        src="rabbit.png"
        alt="Rabbit"
        style="display: block; margin: 20px auto; max-width: 200px"
      />
      <div class="small">Tip: serve from http://localhost while testing (not file://).</div>
    </div>

    <div id="pages"></div>

    <script>
      const OPENAI_RESPONSES_URL = "https://api.openai.com/v1/responses";
      const MODEL = "gpt-5.2-chat-latest";

      const DEFAULT_REASONING_EFFORT = "medium";
      const DEFAULT_VERBOSITY = "medium";

      const MAX_WORDS = 200;

      // Auto-fit settings
      const BASE_FONT_SIZE_PX = 20;
      const MIN_FONT_SIZE_PX = 12;

      let searchTerms = [];
      let apiKey = localStorage.getItem("openaiApiKey") || "";
      if (apiKey) {
        document.getElementById("apiKey").classList.add("hidden");
      }

      let currentPageIndex = 0;
      let pagesLoaded = 0;

      function countWords(text) {
        const tokens = String(text)
          .trim()
          .split(/\s+/)
          .filter(Boolean);
        return tokens.length;
      }

      function clampToWords(text, maxWords) {
        const tokens = String(text).trim().split(/\s+/).filter(Boolean);
        if (tokens.length <= maxWords) return String(text).trim();
        return tokens.slice(0, maxWords).join(" ").trim() + "â€¦";
      }

      function extractOutputText(data) {
        if (!data || !Array.isArray(data.output)) return "";
        const chunks = [];
        for (const item of data.output) {
          if (!item || item.type !== "message") continue;
          if (!Array.isArray(item.content)) continue;
          for (const part of item.content) {
            if (part && part.type === "output_text" && typeof part.text === "string") {
              chunks.push(part.text);
            }
          }
        }
        return chunks.join("\n").trim();
      }

      function isLikelyCorsOrNetworkError(err) {
        const msg = (err && err.message ? err.message : String(err)).toLowerCase();
        return (
          msg.includes("failed to fetch") ||
          msg.includes("networkerror") ||
          msg.includes("cors") ||
          msg.includes("blocked by") ||
          msg.includes("access-control-allow-origin")
        );
      }

      async function openAIResponses({ input, instructions, max_output_tokens }) {
        if (!apiKey) throw new Error("Missing API key.");

        let response;
        let raw = "";

        try {
          response = await fetch(OPENAI_RESPONSES_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer " + apiKey
            },
            body: JSON.stringify({
              model: MODEL,
              instructions,
              input,
              reasoning: { effort: DEFAULT_REASONING_EFFORT },
              text: { verbosity: DEFAULT_VERBOSITY },
              max_output_tokens
            })
          });

          raw = await response.text();
        } catch (err) {
          const extra =
            location.protocol === "file:"
              ? "\n\nYou are running from file://. Serve from http://localhost."
              : "";
          const corsHint = isLikelyCorsOrNetworkError(err)
            ? "\n\nThis looks like a browser CORS or network block. If this is the case, you will need to call OpenAI from a small server proxy rather than directly from the browser."
            : "";
          throw new Error(`${err && err.message ? err.message : String(err)}${extra}${corsHint}`);
        }

        let data = null;
        try {
          data = JSON.parse(raw);
        } catch (_) {}

        if (!response.ok) {
          const apiMsg =
            data && data.error && data.error.message ? data.error.message : raw || "Unknown error";
          throw new Error(`OpenAI error (${response.status}): ${apiMsg}`);
        }

        if (data && data.status === "failed" && data.error) {
          const apiMsg = data.error.message || JSON.stringify(data.error);
          throw new Error(`OpenAI failed: ${apiMsg}`);
        }

        const text = extractOutputText(data);
        if (!text) {
          const status = data && data.status ? data.status : "unknown";
          throw new Error(
            `No output_text found (status: ${status}).\n\nRaw response keys: ${
              data ? Object.keys(data).join(", ") : "none"
            }`
          );
        }

        return text;
      }

      function addErrorPage(title, err) {
        const msg = err && err.message ? err.message : String(err);
        addPage(`${title}\n\n${msg}`);
      }

      function fitsInPage(el) {
        // clientHeight excludes overflow
        // scrollHeight includes overflow content
        return el.scrollHeight <= el.clientHeight;
      }

      function fitTextToPage(el) {
        // Reset per-page to base size first, then shrink only this page
        let low = MIN_FONT_SIZE_PX;
        let high = BASE_FONT_SIZE_PX;

        el.style.fontSize = BASE_FONT_SIZE_PX + "px";

        // If it already fits, we are done
        if (fitsInPage(el)) return;

        // Binary search the maximum font size that fits
        while (high - low > 0.5) {
          const mid = (low + high) / 2;
          el.style.fontSize = mid + "px";

          if (fitsInPage(el)) {
            low = mid;
          } else {
            high = mid;
          }
        }

        el.style.fontSize = Math.max(MIN_FONT_SIZE_PX, Math.floor(low)) + "px";

        // Last resort: if still not fitting (very rare), clamp line height slightly
        if (!fitsInPage(el)) {
          el.style.lineHeight = "1.2";
        }
      }

      function addPage(content) {
        const pagesContainer = document.getElementById("pages");
        const pageDiv = document.createElement("div");
        pageDiv.className = "page";

        // Safety net: clamp to 200 words even if the model overshoots
        const clamped = clampToWords(content, MAX_WORDS);
        pageDiv.innerText = clamped;

        // Ensure per-page base size before fitting
        pageDiv.style.fontSize = BASE_FONT_SIZE_PX + "px";
        pageDiv.style.lineHeight = "1.35";

        pagesContainer.appendChild(pageDiv);
        pagesLoaded++;

        // Fit after the element is in the DOM and layout has happened
        requestAnimationFrame(() => fitTextToPage(pageDiv));
      }

      // If viewport changes (rotate, resize), refit all pages
      window.addEventListener("resize", () => {
        const pages = document.querySelectorAll(".page");
        for (const p of pages) {
          requestAnimationFrame(() => fitTextToPage(p));
        }
      });

      async function getGPTText(term) {
        const prompt =
          `Generate a short, engaging research summary that fills an iPhone screen.\n` +
          `Start with a title that is the search term, then a newline, then a concise summary.\n` +
          `Hard limit: ${MAX_WORDS} words total (including the title).\n` +
          `If you are about to exceed the limit, compress rather than continue.\n` +
          `The search term is: "${term}"`;

        const text = await openAIResponses({
          instructions: "You are a creative and analytical research assistant.",
          input: [{ role: "user", content: prompt }],
          max_output_tokens: 260
        });

        return clampToWords(text, MAX_WORDS);
      }

      async function getChainGPTKeyword() {
        if (!apiKey) return null;

        const prompt =
          `Based on the following chain of subjects: ${searchTerms.join(", ")},\n` +
          `Return a single, concise search term that logically moves deeper into the subject.\n` +
          `Not sideways or elaborating on the same subject. Deeper. Logically continuing the chain of subjects.\n` +
          `Your new chosen topic should be so much deeper that it doesn't include words from the previous search term.\n` +
          `If it's more than 6 words, shorten your new chosen topic into 6 words or less.\n` +
          `Return only the search term.`;

        const text = await openAIResponses({
          instructions: "You are a creative and analytical research assistant.",
          input: [{ role: "user", content: prompt }],
          max_output_tokens: 30
        });

        return text.trim().split("\n")[0].trim();
      }

      async function preloadNextPage() {
        if (pagesLoaded !== currentPageIndex + 1) return;

        try {
          const newTerm = await getChainGPTKeyword();
          if (!newTerm) return;

          const content = await getGPTText(newTerm);
          if (!content) return;

          const title = content.split("\n")[0].trim();
          searchTerms.push(title);
          addPage(content);
        } catch (err) {
          console.error(err);
          addErrorPage("Failed to load next page", err);
        }
      }

      document.getElementById("pages").addEventListener("scroll", () => {
        const pagesContainer = document.getElementById("pages");
        const scrollPosition = pagesContainer.scrollTop;
        const viewportHeight = window.innerHeight;

        if (scrollPosition >= (currentPageIndex + 0.5) * viewportHeight) {
          if (currentPageIndex < pagesLoaded - 1) {
            currentPageIndex++;
            pagesContainer.scrollTo({
              top: currentPageIndex * viewportHeight,
              behavior: "smooth"
            });
            preloadNextPage();
          }
        }
      });

      document.getElementById("okButton").addEventListener("click", async (event) => {
        event.stopPropagation();

        if (!apiKey) {
          apiKey = document.getElementById("apiKey").value.trim();
          if (!apiKey) {
            alert("Please enter a valid API key.");
            return;
          }
          localStorage.setItem("openaiApiKey", apiKey);
          document.getElementById("apiKey").classList.add("hidden");
        }

        const subject = document.getElementById("subjectInput").value.trim();
        if (!subject) {
          alert("Please enter a subject.");
          return;
        }

        document.getElementById("form-container").classList.add("hidden");

        try {
          const content = await getGPTText(subject);
          const title = content.split("\n")[0].trim();
          searchTerms.push(title);
          addPage(content);
          preloadNextPage();
        } catch (err) {
          console.error(err);
          addErrorPage("Failed to generate first page", err);
        }
      });
    </script>
  </body>
</html>
