<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="icon" type="image/png" href="rabbit.png" />
    <link rel="apple-touch-icon" href="rabbit.png" />

    <title>RABBIT HOLE</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: black;
        color: white;
      }
      #form-container {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        z-index: 10;
        width: 100%;
        padding: 20px;
        box-sizing: border-box;
      }
      input,
      button {
        padding: 10px;
        font-size: 24px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
      }
      input {
        width: 100%;
      }
      button {
        cursor: pointer;
        background-color: #444;
        color: white;
      }
      .hidden {
        display: none;
      }
      #pages {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        overflow-y: auto;
        scroll-snap-type: y mandatory;
      }
      .page {
        height: 100vh;
        padding: 20px;
        box-sizing: border-box;
        scroll-snap-align: start;
        white-space: pre-wrap;

        font-size: 20px;
        line-height: 1.35;
      }
      .small {
        opacity: 0.75;
        font-size: 14px;
        margin-top: 10px;
      }
    </style>
  </head>

  <body>
    <div id="form-container">
      <input type="password" id="apiKey" placeholder="Enter your OpenAI API key" />
      <input type="text" id="subjectInput" placeholder="Enter a starting subject" />
      <button id="okButton">OK</button>
      <img
        src="rabbit.png"
        alt="Rabbit"
        style="display: block; margin: 20px auto; max-width: 200px"
      />
      <div class="small">Tip: serve from http://localhost while testing (not file://).</div>
    </div>

    <div id="pages"></div>

    <script>
      const OPENAI_RESPONSES_URL = "https://api.openai.com/v1/responses";

      // Use nano on everything
      const MODEL = "gpt-5-nano";

      // Content constraints
      const MAX_WORDS = 200;

      // Auto-fit settings
      const BASE_FONT_SIZE_PX = 20;
      const MIN_FONT_SIZE_PX = 12;

      // Networking
      const REQUEST_TIMEOUT_MS = 25000;

      // Token budgets
      // Give enough room so "medium" behaviour can still emit visible text.
      const SUMMARY_MAX_OUTPUT_TOKENS = 1200;
      const SUMMARY_RETRY_MAX_OUTPUT_TOKENS = 2400;

      const CHAIN_MAX_OUTPUT_TOKENS = 120;
      const CHAIN_RETRY_MAX_OUTPUT_TOKENS = 240;

      let searchTerms = [];
      let apiKey = localStorage.getItem("openaiApiKey") || "";
      if (apiKey) {
        document.getElementById("apiKey").classList.add("hidden");
      }

      let currentPageIndex = 0;
      let pagesLoaded = 0;
      let nextPageInFlight = false;

      function clampToWords(text, maxWords) {
        const tokens = String(text).trim().split(/\s+/).filter(Boolean);
        if (tokens.length <= maxWords) return String(text).trim();
        return tokens.slice(0, maxWords).join(" ").trim() + "…";
      }

      function extractOutputText(data) {
        if (!data) return "";

        // Convenience field (sometimes present)
        if (typeof data.output_text === "string" && data.output_text.trim()) {
          return data.output_text.trim();
        }

        // Standard Responses output parsing
        if (!Array.isArray(data.output)) return "";

        const chunks = [];
        for (const item of data.output) {
          if (item && item.type === "message" && Array.isArray(item.content)) {
            for (const part of item.content) {
              if (part && part.type === "output_text" && typeof part.text === "string") {
                chunks.push(part.text);
              }
            }
          } else if (item && item.type === "output_text" && typeof item.text === "string") {
            chunks.push(item.text);
          }
        }
        return chunks.join("\n").trim();
      }

      function isLikelyCorsOrNetworkError(err) {
        const msg = (err && err.message ? err.message : String(err)).toLowerCase();
        return (
          msg.includes("failed to fetch") ||
          msg.includes("networkerror") ||
          msg.includes("cors") ||
          msg.includes("blocked by") ||
          msg.includes("access-control-allow-origin")
        );
      }

      function fetchWithTimeout(url, options, timeoutMs) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeoutMs);
        return fetch(url, { ...options, signal: controller.signal }).finally(() => clearTimeout(id));
      }

      async function openAIResponsesOnce({ input, instructions, max_output_tokens }) {
        if (!apiKey) throw new Error("Missing API key.");

        let response;
        let raw = "";

        try {
          response = await fetchWithTimeout(
            OPENAI_RESPONSES_URL,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + apiKey
              },
              body: JSON.stringify({
                model: MODEL,
                instructions,
                input,

                // Important: do NOT set reasoning/text params here.
                // Defaults apply (medium), matching your requirement.

                max_output_tokens
              })
            },
            REQUEST_TIMEOUT_MS
          );
          raw = await response.text();
        } catch (err) {
          const extra =
            location.protocol === "file:"
              ? "\n\nYou are running from file://. Serve from http://localhost."
              : "";
          const corsHint = isLikelyCorsOrNetworkError(err)
            ? "\n\nThis looks like a browser CORS or network block. If this is the case, you will need to call OpenAI from a small server proxy rather than directly from the browser."
            : "";
          const timeoutHint =
            err && err.name === "AbortError"
              ? "\n\nRequest timed out. Try increasing REQUEST_TIMEOUT_MS."
              : "";
          throw new Error(
            `${err && err.message ? err.message : String(err)}${extra}${corsHint}${timeoutHint}`
          );
        }

        let data = null;
        try {
          data = JSON.parse(raw);
        } catch (_) {}

        if (!response.ok) {
          const apiMsg =
            data && data.error && data.error.message ? data.error.message : raw || "Unknown error";
          throw new Error(`OpenAI error (${response.status}): ${apiMsg}`);
        }

        if (data && data.status === "failed" && data.error) {
          const apiMsg = data.error.message || JSON.stringify(data.error);
          throw new Error(`OpenAI failed: ${apiMsg}`);
        }

        return data;
      }

      async function openAIResponsesWithRetry({ input, instructions, max_output_tokens, retry_max_output_tokens }) {
        const data1 = await openAIResponsesOnce({ input, instructions, max_output_tokens });
        const text1 = extractOutputText(data1);

        // If we got text, return it regardless of status.
        if (text1) return { text: text1, data: data1 };

        // If no text and status is incomplete, retry once with a larger budget.
        const status1 = data1 && data1.status ? data1.status : "unknown";
        const incompleteReason =
          data1 && data1.incomplete_details && data1.incomplete_details.reason
            ? data1.incomplete_details.reason
            : "";

        if (status1 === "incomplete" && retry_max_output_tokens) {
          const data2 = await openAIResponsesOnce({
            input,
            instructions,
            max_output_tokens: retry_max_output_tokens
          });
          const text2 = extractOutputText(data2);
          if (text2) return { text: text2, data: data2 };

          const status2 = data2 && data2.status ? data2.status : "unknown";
          const reason2 =
            data2 && data2.incomplete_details && data2.incomplete_details.reason
              ? data2.incomplete_details.reason
              : "";

          throw new Error(
            `No text found in response (status: ${status2}).` +
              (reason2 ? `\n\nincomplete_details.reason: ${reason2}` : "") +
              `\n\nRaw response keys: ${data2 ? Object.keys(data2).join(", ") : "none"}`
          );
        }

        throw new Error(
          `No text found in response (status: ${status1}).` +
            (incompleteReason ? `\n\nincomplete_details.reason: ${incompleteReason}` : "") +
            `\n\nRaw response keys: ${data1 ? Object.keys(data1).join(", ") : "none"}`
        );
      }

      function fitsInPage(el) {
        return el.scrollHeight <= el.clientHeight;
      }

      function fitTextToPage(el) {
        let low = MIN_FONT_SIZE_PX;
        let high = BASE_FONT_SIZE_PX;

        el.style.fontSize = BASE_FONT_SIZE_PX + "px";
        el.style.lineHeight = "1.35";

        if (fitsInPage(el)) return;

        while (high - low > 0.5) {
          const mid = (low + high) / 2;
          el.style.fontSize = mid + "px";
          if (fitsInPage(el)) {
            low = mid;
          } else {
            high = mid;
          }
        }

        el.style.fontSize = Math.max(MIN_FONT_SIZE_PX, Math.floor(low)) + "px";

        if (!fitsInPage(el)) {
          el.style.lineHeight = "1.2";
        }
      }

      function createPageElement(text) {
        const pageDiv = document.createElement("div");
        pageDiv.className = "page";
        pageDiv.innerText = clampToWords(text, MAX_WORDS);
        pageDiv.style.fontSize = BASE_FONT_SIZE_PX + "px";
        pageDiv.style.lineHeight = "1.35";
        return pageDiv;
      }

      function addPage(content) {
        const pagesContainer = document.getElementById("pages");
        const pageDiv = createPageElement(content);
        pagesContainer.appendChild(pageDiv);
        pagesLoaded++;
        requestAnimationFrame(() => fitTextToPage(pageDiv));
        return pageDiv;
      }

      function addLoadingPage() {
        return addPage("Loading…");
      }

      function addErrorPage(title, err) {
        const msg = err && err.message ? err.message : String(err);
        addPage(`${title}\n\n${msg}`);
      }

      window.addEventListener("resize", () => {
        const pages = document.querySelectorAll(".page");
        for (const p of pages) {
          requestAnimationFrame(() => fitTextToPage(p));
        }
      });

      async function getGPTText(term) {
        const prompt =
          `Generate a short, engaging research summary that fills an iPhone screen.\n` +
          `Format:\n` +
          `Line 1: the title (exactly the search term)\n` +
          `Line 2+: the summary\n\n` +
          `Hard limit: ${MAX_WORDS} words total (including the title).\n` +
          `If you are about to exceed the limit, compress rather than continue.\n` +
          `No markdown.\n\n` +
          `The search term is: "${term}"`;

        const { text } = await openAIResponsesWithRetry({
          instructions: "You are a creative and analytical research assistant.",
          input: [{ role: "user", content: prompt }],
          max_output_tokens: SUMMARY_MAX_OUTPUT_TOKENS,
          retry_max_output_tokens: SUMMARY_RETRY_MAX_OUTPUT_TOKENS
        });

        return clampToWords(text, MAX_WORDS);
      }

      async function getChainGPTKeyword() {
        const prompt =
          `Based on the following chain of subjects: ${searchTerms.join(", ")},\n` +
          `Return a single, concise search term that logically moves deeper into the subject.\n` +
          `Not sideways or elaborating on the same subject. Deeper. Logically continuing the chain.\n` +
          `Your new chosen topic should be so much deeper that it doesn't include words from the previous search term.\n` +
          `If it's more than 6 words, shorten it to 6 words or less.\n` +
          `Return only the search term. No punctuation. No quotes.`;

        const { text } = await openAIResponsesWithRetry({
          instructions: "You are a creative and analytical research assistant.",
          input: [{ role: "user", content: prompt }],
          max_output_tokens: CHAIN_MAX_OUTPUT_TOKENS,
          retry_max_output_tokens: CHAIN_RETRY_MAX_OUTPUT_TOKENS
        });

        return text.trim().split("\n")[0].trim();
      }

      async function generateIntoPlaceholder(placeholderEl) {
        const newTerm = await getChainGPTKeyword();
        if (!newTerm) throw new Error("No term generated.");

        const content = await getGPTText(newTerm);
        if (!content) throw new Error("No content generated.");

        const title = content.split("\n")[0].trim();
        searchTerms.push(title);

        placeholderEl.innerText = clampToWords(content, MAX_WORDS);
        placeholderEl.style.fontSize = BASE_FONT_SIZE_PX + "px";
        placeholderEl.style.lineHeight = "1.35";
        requestAnimationFrame(() => fitTextToPage(placeholderEl));
      }

      async function ensureNextPageLoaded() {
        if (nextPageInFlight) return;
        if (pagesLoaded > currentPageIndex + 1) return;

        nextPageInFlight = true;

        const placeholder = addLoadingPage();

        try {
          await generateIntoPlaceholder(placeholder);
        } catch (err) {
          console.error(err);
          placeholder.innerText = `Failed to load next page\n\n${
            err && err.message ? err.message : String(err)
          }`;
          placeholder.style.fontSize = BASE_FONT_SIZE_PX + "px";
          placeholder.style.lineHeight = "1.35";
          requestAnimationFrame(() => fitTextToPage(placeholder));
        } finally {
          nextPageInFlight = false;
        }
      }

      document.getElementById("pages").addEventListener("scroll", () => {
        const pagesContainer = document.getElementById("pages");
        const scrollPosition = pagesContainer.scrollTop;
        const viewportHeight = window.innerHeight;

        if (scrollPosition >= (currentPageIndex + 0.5) * viewportHeight) {
          if (currentPageIndex < pagesLoaded - 1) {
            currentPageIndex++;
            pagesContainer.scrollTo({
              top: currentPageIndex * viewportHeight,
              behavior: "smooth"
            });
            ensureNextPageLoaded();
          } else {
            ensureNextPageLoaded();
          }
        }
      });

      document.getElementById("okButton").addEventListener("click", async (event) => {
        event.stopPropagation();

        if (!apiKey) {
          apiKey = document.getElementById("apiKey").value.trim();
          if (!apiKey) {
            alert("Please enter a valid API key.");
            return;
          }
          localStorage.setItem("openaiApiKey", apiKey);
          document.getElementById("apiKey").classList.add("hidden");
        }

        const subject = document.getElementById("subjectInput").value.trim();
        if (!subject) {
          alert("Please enter a subject.");
          return;
        }

        document.getElementById("form-container").classList.add("hidden");

        try {
          const content = await getGPTText(subject);
          const title = content.split("\n")[0].trim();
          searchTerms.push(title);
          addPage(content);

          ensureNextPageLoaded();
        } catch (err) {
          console.error(err);
          addErrorPage("Failed to generate first page", err);
        }
      });
    </script>
  </body>
</html>
