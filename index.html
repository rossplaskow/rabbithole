<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="icon" type="image/png" href="rabbit.png" />
    <link rel="apple-touch-icon" href="rabbit.png" />

    <title>RABBIT HOLE</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: black;
        color: white;
      }
      #form-container {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        z-index: 10;
        width: 100%;
        padding: 20px;
        box-sizing: border-box;
      }
      input,
      button {
        padding: 10px;
        font-size: 24px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
      }
      input {
        width: 100%;
      }
      button {
        cursor: pointer;
        background-color: #444;
        color: white;
      }
      .hidden {
        display: none;
      }
      #pages {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        overflow-y: auto;
        scroll-snap-type: y mandatory;
      }
      .page {
        height: 100vh;
        padding: 20px;
        box-sizing: border-box;
        scroll-snap-align: start;
        white-space: pre-wrap;
        font-size: 20px;
        line-height: 1.35;
      }
      .small {
        opacity: 0.75;
        font-size: 14px;
        margin-top: 10px;
      }
    </style>
  </head>

  <body>
    <div id="form-container">
      <input type="password" id="apiKey" placeholder="Enter your OpenAI API key" />
      <input type="text" id="subjectInput" placeholder="Enter a starting subject" />
      <button id="okButton">OK</button>
      <img
        src="rabbit.png"
        alt="Rabbit"
        style="display: block; margin: 20px auto; max-width: 200px"
      />
      <div class="small">Tip: serve from http://localhost while testing (not file://).</div>
    </div>

    <div id="pages"></div>

    <script>
      const OPENAI_RESPONSES_URL = "https://api.openai.com/v1/responses";
      const MODEL = "gpt-5-nano";

      // Your constraint
      const REASONING_EFFORT = "medium";
      const VERBOSITY = "medium";

      // Content constraints
      const MAX_WORDS = 200;
      const MAX_CHAIN_WORDS = 6;

      // Auto-fit
      const BASE_FONT_SIZE_PX = 20;
      const MIN_FONT_SIZE_PX = 12;

      // Streaming safety
      const REQUEST_TIMEOUT_MS = 30000;

      // Make this high to avoid "incomplete" before output when reasoning is medium.
      // We will abort early once we have enough words.
      const HIGH_MAX_OUTPUT_TOKENS_SUMMARY = 12000;
      const HIGH_MAX_OUTPUT_TOKENS_CHAIN = 6000;

      let apiKey = localStorage.getItem("openaiApiKey") || "";
      if (apiKey) document.getElementById("apiKey").classList.add("hidden");

      let searchTerms = [];
      let currentPageIndex = 0;
      let pagesLoaded = 0;
      let nextPageInFlight = false;

      function wordCount(text) {
        return String(text).trim().split(/\s+/).filter(Boolean).length;
      }

      function clampToWords(text, maxWords) {
        const tokens = String(text).trim().split(/\s+/).filter(Boolean);
        if (tokens.length <= maxWords) return String(text).trim();
        return tokens.slice(0, maxWords).join(" ").trim() + "…";
      }

      function fitsInPage(el) {
        return el.scrollHeight <= el.clientHeight;
      }

      function fitTextToPage(el) {
        let low = MIN_FONT_SIZE_PX;
        let high = BASE_FONT_SIZE_PX;

        el.style.fontSize = BASE_FONT_SIZE_PX + "px";
        el.style.lineHeight = "1.35";

        if (fitsInPage(el)) return;

        while (high - low > 0.5) {
          const mid = (low + high) / 2;
          el.style.fontSize = mid + "px";
          if (fitsInPage(el)) low = mid;
          else high = mid;
        }

        el.style.fontSize = Math.max(MIN_FONT_SIZE_PX, Math.floor(low)) + "px";

        if (!fitsInPage(el)) el.style.lineHeight = "1.2";
      }

      function createPageElement(text) {
        const pageDiv = document.createElement("div");
        pageDiv.className = "page";
        pageDiv.innerText = text;
        pageDiv.style.fontSize = BASE_FONT_SIZE_PX + "px";
        pageDiv.style.lineHeight = "1.35";
        return pageDiv;
      }

      function addPage(content) {
        const pagesContainer = document.getElementById("pages");
        const pageDiv = createPageElement(content);
        pagesContainer.appendChild(pageDiv);
        pagesLoaded++;
        requestAnimationFrame(() => fitTextToPage(pageDiv));
        return pageDiv;
      }

      function addLoadingPage() {
        return addPage("Loading…");
      }

      function addErrorPage(title, err) {
        const msg = err && err.message ? err.message : String(err);
        addPage(`${title}\n\n${msg}`);
      }

      window.addEventListener("resize", () => {
        const pages = document.querySelectorAll(".page");
        for (const p of pages) requestAnimationFrame(() => fitTextToPage(p));
      });

      function isLikelyCorsOrNetworkError(err) {
        const msg = (err && err.message ? err.message : String(err)).toLowerCase();
        return (
          msg.includes("failed to fetch") ||
          msg.includes("networkerror") ||
          msg.includes("cors") ||
          msg.includes("blocked by") ||
          msg.includes("access-control-allow-origin")
        );
      }

      function makeAbortTimeout(controller, timeoutMs) {
        const id = setTimeout(() => controller.abort(), timeoutMs);
        return () => clearTimeout(id);
      }

      // Robust SSE text delta extractor for Responses streaming.
      // It tries several event shapes seen across versions.
      function extractDeltaTextFromEvent(evt) {
        if (!evt) return "";

        // Common: { type: "response.output_text.delta", delta: "..." }
        if (evt.type === "response.output_text.delta" && typeof evt.delta === "string") return evt.delta;

        // Sometimes: { type: "...", text: "..." }
        if (typeof evt.text === "string" && evt.type && String(evt.type).includes("delta")) return evt.text;

        // Sometimes: { type: "response.output.delta", delta: { ... } } or nested structures
        if (evt.delta) {
          if (typeof evt.delta === "string") return evt.delta;
          if (evt.delta && typeof evt.delta.text === "string") return evt.delta.text;
          if (evt.delta && evt.delta.content && Array.isArray(evt.delta.content)) {
            const parts = [];
            for (const p of evt.delta.content) {
              if (p && typeof p.text === "string") parts.push(p.text);
            }
            if (parts.length) return parts.join("");
          }
        }

        // Fallback: some servers send final response objects during stream
        // Try to pull any output_text convenience field
        if (typeof evt.output_text === "string") return evt.output_text;

        return "";
      }

      async function streamResponse({
        instructions,
        input,
        max_output_tokens,
        onText,
        shouldStop
      }) {
        if (!apiKey) throw new Error("Missing API key.");

        const controller = new AbortController();
        const clearTimeoutFn = makeAbortTimeout(controller, REQUEST_TIMEOUT_MS);

        let response;
        try {
          response = await fetch(OPENAI_RESPONSES_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer " + apiKey
            },
            signal: controller.signal,
            body: JSON.stringify({
              model: MODEL,
              stream: true,

              instructions,
              input,

              reasoning: { effort: REASONING_EFFORT },
              text: { verbosity: VERBOSITY },

              max_output_tokens
            })
          });
        } catch (err) {
          clearTimeoutFn();
          const extra =
            location.protocol === "file:"
              ? "\n\nYou are running from file://. Serve from http://localhost."
              : "";
          const corsHint = isLikelyCorsOrNetworkError(err)
            ? "\n\nThis looks like a browser CORS or network block."
            : "";
          throw new Error(`${err && err.message ? err.message : String(err)}${extra}${corsHint}`);
        }

        if (!response.ok) {
          clearTimeoutFn();
          const raw = await response.text().catch(() => "");
          let data = null;
          try { data = JSON.parse(raw); } catch (_) {}
          const apiMsg = data && data.error && data.error.message ? data.error.message : raw || "Unknown error";
          throw new Error(`OpenAI error (${response.status}): ${apiMsg}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        let fullText = "";

        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });

            // SSE frames separated by blank lines
            const parts = buffer.split("\n\n");
            buffer = parts.pop() || "";

            for (const part of parts) {
              const lines = part.split("\n").map((l) => l.trim());
              for (const line of lines) {
                if (!line.startsWith("data:")) continue;

                const payload = line.slice(5).trim();
                if (!payload) continue;

                if (payload === "[DONE]") {
                  clearTimeoutFn();
                  return fullText;
                }

                let evt = null;
                try {
                  evt = JSON.parse(payload);
                } catch (_) {
                  continue;
                }

                const delta = extractDeltaTextFromEvent(evt);
                if (delta) {
                  fullText += delta;
                  onText(delta, fullText);

                  if (shouldStop && shouldStop(fullText)) {
                    controller.abort();
                    clearTimeoutFn();
                    return fullText;
                  }
                }

                // Some streams send final response object with a "response.completed" type
                if (evt && evt.type && String(evt.type).includes("completed")) {
                  clearTimeoutFn();
                  return fullText;
                }
              }
            }
          }
        } catch (err) {
          // Abort is expected when we stop early.
          if (err && err.name === "AbortError") {
            clearTimeoutFn();
            return fullText;
          }
          clearTimeoutFn();
          throw err;
        }

        clearTimeoutFn();
        return fullText;
      }

      async function getChainTermStreaming() {
        const prompt =
          `Based on the following chain of subjects: ${searchTerms.join(", ")},\n` +
          `Return a single concise search term that moves deeper into the subject.\n` +
          `No words from the previous term.\n` +
          `Maximum ${MAX_CHAIN_WORDS} words.\n` +
          `Return only the search term.`;

        let captured = "";
        const text = await streamResponse({
          instructions: "You are a creative and analytical research assistant.",
          input: [{ role: "user", content: prompt }],
          max_output_tokens: HIGH_MAX_OUTPUT_TOKENS_CHAIN,
          onText: (delta, full) => { captured = full; },
          shouldStop: (full) => {
            // Stop once we have a line, or enough words
            const firstLine = full.split("\n")[0].trim();
            if (!firstLine) return false;
            if (wordCount(firstLine) >= MAX_CHAIN_WORDS) return true;
            // If it looks complete (ends with no trailing partial), stop once it is short enough
            return wordCount(firstLine) >= 2 && wordCount(firstLine) <= MAX_CHAIN_WORDS && firstLine.length >= 6;
          }
        });

        const firstLine = (captured || text).trim().split("\n")[0].trim();
        return firstLine;
      }

      async function getSummaryStreaming(term, pageEl) {
        const prompt =
          `Generate a short, engaging research summary that fills an iPhone screen.\n` +
          `Format:\n` +
          `Line 1: title (exactly the search term)\n` +
          `Line 2+: summary\n\n` +
          `Hard limit: ${MAX_WORDS} words total.\n` +
          `No markdown.\n\n` +
          `The search term is: "${term}"`;

        let full = "";

        // Reset page to base styling each time we fill it
        pageEl.style.fontSize = BASE_FONT_SIZE_PX + "px";
        pageEl.style.lineHeight = "1.35";
        pageEl.innerText = "";

        const streamed = await streamResponse({
          instructions: "You are a creative and analytical research assistant.",
          input: [{ role: "user", content: prompt }],
          max_output_tokens: HIGH_MAX_OUTPUT_TOKENS_SUMMARY,
          onText: (delta, now) => {
            full = now;
            // Show partial but clamped to avoid crazy overflow while streaming
            pageEl.innerText = clampToWords(full, MAX_WORDS);
            requestAnimationFrame(() => fitTextToPage(pageEl));
          },
          shouldStop: (now) => wordCount(now) >= MAX_WORDS
        });

        full = streamed || full;
        return clampToWords(full, MAX_WORDS);
      }

      async function generateIntoPlaceholder(placeholderEl) {
        const newTerm = await getChainTermStreaming();
        if (!newTerm) throw new Error("No term generated.");

        const content = await getSummaryStreaming(newTerm, placeholderEl);
        if (!content) throw new Error("No content generated.");

        const title = content.split("\n")[0].trim();
        searchTerms.push(title);

        placeholderEl.innerText = content;
        requestAnimationFrame(() => fitTextToPage(placeholderEl));
      }

      async function ensureNextPageLoaded() {
        if (nextPageInFlight) return;
        if (pagesLoaded > currentPageIndex + 1) return;

        nextPageInFlight = true;
        const placeholder = addLoadingPage();

        try {
          await generateIntoPlaceholder(placeholder);
        } catch (err) {
          console.error(err);
          placeholder.innerText =
            `Failed to load next page\n\n${err && err.message ? err.message : String(err)}`;
          placeholder.style.fontSize = BASE_FONT_SIZE_PX + "px";
          placeholder.style.lineHeight = "1.35";
          requestAnimationFrame(() => fitTextToPage(placeholder));
        } finally {
          nextPageInFlight = false;
        }
      }

      document.getElementById("pages").addEventListener("scroll", () => {
        const pagesContainer = document.getElementById("pages");
        const scrollPosition = pagesContainer.scrollTop;
        const viewportHeight = window.innerHeight;

        if (scrollPosition >= (currentPageIndex + 0.5) * viewportHeight) {
          if (currentPageIndex < pagesLoaded - 1) {
            currentPageIndex++;
            pagesContainer.scrollTo({ top: currentPageIndex * viewportHeight, behavior: "smooth" });
            ensureNextPageLoaded();
          } else {
            ensureNextPageLoaded();
          }
        }
      });

      document.getElementById("okButton").addEventListener("click", async (event) => {
        event.stopPropagation();

        if (!apiKey) {
          apiKey = document.getElementById("apiKey").value.trim();
          if (!apiKey) {
            alert("Please enter a valid API key.");
            return;
          }
          localStorage.setItem("openaiApiKey", apiKey);
          document.getElementById("apiKey").classList.add("hidden");
        }

        const subject = document.getElementById("subjectInput").value.trim();
        if (!subject) {
          alert("Please enter a subject.");
          return;
        }

        document.getElementById("form-container").classList.add("hidden");

        try {
          // First page as a placeholder too, so we can stream into it
          const firstPage = addLoadingPage();
          const content = await getSummaryStreaming(subject, firstPage);

          const title = content.split("\n")[0].trim();
          searchTerms.push(title);

          firstPage.innerText = content;
          requestAnimationFrame(() => fitTextToPage(firstPage));

          ensureNextPageLoaded();
        } catch (err) {
          console.error(err);
          addErrorPage("Failed to generate first page", err);
        }
      });
    </script>
  </body>
</html>