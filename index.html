<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="icon" type="image/png" href="rabbit.png" />
    <link rel="apple-touch-icon" href="rabbit.png" />

    <title>RABBIT HOLE</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: black;
        color: white;
      }
      #form-container {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        z-index: 10;
        width: 100%;
        padding: 20px;
        box-sizing: border-box;
      }
      input,
      button {
        padding: 10px;
        font-size: 24px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
      }
      input {
        width: 100%;
      }
      button {
        cursor: pointer;
        background-color: #444;
        color: white;
      }
      .hidden {
        display: none;
      }
      #pages {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        overflow-y: auto;
        scroll-snap-type: y mandatory;
        -webkit-overflow-scrolling: touch;
      }
      .page {
        height: 100vh;
        padding: 20px;
        box-sizing: border-box;
        scroll-snap-align: start;
        white-space: pre-wrap;
        font-size: 20px;
        line-height: 1.35;
      }
      .small {
        opacity: 0.75;
        font-size: 14px;
        margin-top: 10px;
      }
    </style>
  </head>

  <body>
    <div id="form-container">
      <input type="password" id="apiKey" placeholder="Enter your OpenAI API key" />
      <input type="text" id="subjectInput" placeholder="Enter a starting subject" />
      <button id="okButton">OK</button>
      <img
        src="rabbit.png"
        alt="Rabbit"
        style="display: block; margin: 20px auto; max-width: 200px"
      />
      <div class="small">Tip: serve from http://localhost while testing (not file://).</div>
    </div>

    <div id="pages"></div>

    <script>
      const OPENAI_RESPONSES_URL = "https://api.openai.com/v1/responses";
      const MODEL = "gpt-5-nano";

      // Your constraint
      const REASONING_EFFORT = "medium";
      const VERBOSITY = "medium";

      // Content constraints
      const MAX_WORDS = 100;
      const MAX_CHAIN_WORDS = 4;

      // Auto-fit
      const BASE_FONT_SIZE_PX = 20;
      const MIN_FONT_SIZE_PX = 12;

      // Streaming safety
      const REQUEST_TIMEOUT_MS = 30000;

      // Set high and abort early once we have enough words
      const HIGH_MAX_OUTPUT_TOKENS_SUMMARY = 12000;
      const HIGH_MAX_OUTPUT_TOKENS_CHAIN = 6000;

      // Keep this many pages ready ahead of the one being read
      const AHEAD_BUFFER_PAGES = 2;

      let apiKey = localStorage.getItem("openaiApiKey") || "";
      if (apiKey) document.getElementById("apiKey").classList.add("hidden");

      let searchTerms = [];
      let pagesLoaded = 0;
      let currentPageIndex = 0;

      let queueInFlight = 0;
      let pendingAbortControllers = new Set();

      const pagesContainer = document.getElementById("pages");

      function wordCount(text) {
        return String(text).trim().split(/\s+/).filter(Boolean).length;
      }

      function clampToWords(text, maxWords) {
        const tokens = String(text).trim().split(/\s+/).filter(Boolean);
        if (tokens.length <= maxWords) return String(text).trim();
        return tokens.slice(0, maxWords).join(" ").trim() + "…";
      }

      function fitsInPage(el) {
        return el.scrollHeight <= el.clientHeight;
      }

      function fitTextToPage(el) {
        let low = MIN_FONT_SIZE_PX;
        let high = BASE_FONT_SIZE_PX;

        el.style.fontSize = BASE_FONT_SIZE_PX + "px";
        el.style.lineHeight = "1.35";

        if (fitsInPage(el)) return;

        while (high - low > 0.5) {
          const mid = (low + high) / 2;
          el.style.fontSize = mid + "px";
          if (fitsInPage(el)) low = mid;
          else high = mid;
        }

        el.style.fontSize = Math.max(MIN_FONT_SIZE_PX, Math.floor(low)) + "px";
        if (!fitsInPage(el)) el.style.lineHeight = "1.2";
      }

      function addPage(content) {
        const pageDiv = document.createElement("div");
        pageDiv.className = "page";
        pageDiv.innerText = content;
        pageDiv.style.fontSize = BASE_FONT_SIZE_PX + "px";
        pageDiv.style.lineHeight = "1.35";
        pagesContainer.appendChild(pageDiv);
        pagesLoaded++;
        requestAnimationFrame(() => fitTextToPage(pageDiv));
        return pageDiv;
      }

      function updatePage(pageEl, content) {
        pageEl.innerText = content;
        pageEl.style.fontSize = BASE_FONT_SIZE_PX + "px";
        pageEl.style.lineHeight = "1.35";
        requestAnimationFrame(() => fitTextToPage(pageEl));
      }

      function addErrorPage(title, err) {
        const msg = err && err.message ? err.message : String(err);
        addPage(`${title}\n\n${msg}`);
      }

      window.addEventListener("resize", () => {
        const pages = document.querySelectorAll(".page");
        for (const p of pages) requestAnimationFrame(() => fitTextToPage(p));
      });

      function isLikelyCorsOrNetworkError(err) {
        const msg = (err && err.message ? err.message : String(err)).toLowerCase();
        return (
          msg.includes("failed to fetch") ||
          msg.includes("networkerror") ||
          msg.includes("cors") ||
          msg.includes("blocked by") ||
          msg.includes("access-control-allow-origin")
        );
      }

      function makeAbortTimeout(controller, timeoutMs) {
        const id = setTimeout(() => controller.abort(), timeoutMs);
        return () => clearTimeout(id);
      }

      function extractDeltaTextFromEvent(evt) {
        if (!evt) return "";
        if (evt.type === "response.output_text.delta" && typeof evt.delta === "string") return evt.delta;
        if (typeof evt.text === "string" && evt.type && String(evt.type).includes("delta")) return evt.text;
        if (evt.delta) {
          if (typeof evt.delta === "string") return evt.delta;
          if (evt.delta && typeof evt.delta.text === "string") return evt.delta.text;
          if (evt.delta && evt.delta.content && Array.isArray(evt.delta.content)) {
            const parts = [];
            for (const p of evt.delta.content) {
              if (p && typeof p.text === "string") parts.push(p.text);
            }
            if (parts.length) return parts.join("");
          }
        }
        if (typeof evt.output_text === "string") return evt.output_text;
        return "";
      }

      async function streamResponse({ instructions, input, max_output_tokens, onText, shouldStop }) {
        if (!apiKey) throw new Error("Missing API key.");

        const controller = new AbortController();
        pendingAbortControllers.add(controller);
        const clearTimeoutFn = makeAbortTimeout(controller, REQUEST_TIMEOUT_MS);

        let response;
        try {
          response = await fetch(OPENAI_RESPONSES_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer " + apiKey
            },
            signal: controller.signal,
            body: JSON.stringify({
              model: MODEL,
              stream: true,
              instructions,
              input,
              reasoning: { effort: REASONING_EFFORT },
              text: { verbosity: VERBOSITY },
              max_output_tokens
            })
          });
        } catch (err) {
          clearTimeoutFn();
          pendingAbortControllers.delete(controller);
          const extra =
            location.protocol === "file:"
              ? "\n\nYou are running from file://. Serve from http://localhost."
              : "";
          const corsHint = isLikelyCorsOrNetworkError(err)
            ? "\n\nThis looks like a browser CORS or network block."
            : "";
          throw new Error(`${err && err.message ? err.message : String(err)}${extra}${corsHint}`);
        }

        if (!response.ok) {
          clearTimeoutFn();
          pendingAbortControllers.delete(controller);
          const raw = await response.text().catch(() => "");
          let data = null;
          try { data = JSON.parse(raw); } catch (_) {}
          const apiMsg = data && data.error && data.error.message ? data.error.message : raw || "Unknown error";
          throw new Error(`OpenAI error (${response.status}): ${apiMsg}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        let fullText = "";

        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const frames = buffer.split("\n\n");
            buffer = frames.pop() || "";

            for (const frame of frames) {
              const lines = frame.split("\n").map((l) => l.trim());
              for (const line of lines) {
                if (!line.startsWith("data:")) continue;

                const payload = line.slice(5).trim();
                if (!payload) continue;

                if (payload === "[DONE]") {
                  clearTimeoutFn();
                  pendingAbortControllers.delete(controller);
                  return fullText;
                }

                let evt = null;
                try { evt = JSON.parse(payload); } catch (_) { continue; }

                const delta = extractDeltaTextFromEvent(evt);
                if (delta) {
                  fullText += delta;
                  if (onText) onText(delta, fullText);

                  if (shouldStop && shouldStop(fullText)) {
                    controller.abort();
                    clearTimeoutFn();
                    pendingAbortControllers.delete(controller);
                    return fullText;
                  }
                }

                if (evt && evt.type && String(evt.type).includes("completed")) {
                  clearTimeoutFn();
                  pendingAbortControllers.delete(controller);
                  return fullText;
                }
              }
            }
          }
        } catch (err) {
          pendingAbortControllers.delete(controller);
          if (err && err.name === "AbortError") {
            clearTimeoutFn();
            return fullText;
          }
          clearTimeoutFn();
          throw err;
        }

        clearTimeoutFn();
        pendingAbortControllers.delete(controller);
        return fullText;
      }

      async function getChainTermStreaming() {
        const prompt =
          `Based on the following chain of subjects: ${searchTerms.join(", ")},\n` +
          `Return a single concise search term that moves deeper into the wider subject.\n` +
          `No words from the previous terms can be used.\n` +
          `Maximum ${MAX_CHAIN_WORDS} words.\n` +
          `Return only the search term.`;

        let captured = "";
        const text = await streamResponse({
          instructions: "You are a creative and analytical research assistant.",
          input: [{ role: "user", content: prompt }],
          max_output_tokens: HIGH_MAX_OUTPUT_TOKENS_CHAIN,
          onText: (delta, full) => { captured = full; },
          shouldStop: (full) => {
            const firstLine = full.split("\n")[0].trim();
            if (!firstLine) return false;
            const wc = wordCount(firstLine);
            return wc >= 2 && wc <= MAX_CHAIN_WORDS && firstLine.length >= 6;
          }
        });

        return (captured || text).trim().split("\n")[0].trim();
      }

      async function streamSummaryIntoPage(term, pageEl) {
        const prompt =
          `Generate a short summary of the subject.\n` +
          `Format:\n` +
          `Line 1: title (exactly the search term)\n` +
          `Line 2+: summary\n\n` +
          `Hard limit: ${MAX_WORDS} words total.\n` +
          `No markdown.\n\n` +
          `The search term is: "${term}"`;

        let full = "";
        updatePage(pageEl, "");

        const streamed = await streamResponse({
          instructions: "You are a creative and analytical research assistant.",
          input: [{ role: "user", content: prompt }],
          max_output_tokens: HIGH_MAX_OUTPUT_TOKENS_SUMMARY,
          onText: (delta, now) => {
            full = now;
            updatePage(pageEl, clampToWords(full, MAX_WORDS));
          },
          shouldStop: (now) => wordCount(now) >= MAX_WORDS
        });

        full = streamed || full;
        return clampToWords(full, MAX_WORDS);
      }

      async function buildNextPageContentInto(pageEl) {
        const newTerm = await getChainTermStreaming();
        if (!newTerm) throw new Error("No term generated.");

        const summary = await streamSummaryIntoPage(newTerm, pageEl);
        if (!summary) throw new Error("No summary generated.");

        const title = summary.split("\n")[0].trim();
        if (title) searchTerms.push(title);

        updatePage(pageEl, summary);
      }

      function pagesAheadCount() {
        return pagesLoaded - (currentPageIndex + 1);
      }

      async function ensureAheadBuffer() {
        // Allow multiple pages to be queued, but do not start too many at once
        while (pagesAheadCount() < AHEAD_BUFFER_PAGES) {
          queueInFlight++;
          const pageEl = addPage("Loading…");
          try {
            await buildNextPageContentInto(pageEl);
          } catch (err) {
            console.error(err);
            updatePage(
              pageEl,
              `Failed to load next page\n\n${err && err.message ? err.message : String(err)}`
            );
          } finally {
            queueInFlight--;
          }

          // If user scrolls fast, keep looping until buffer is restored
          if (queueInFlight > 0) break;
        }
      }

      // IntersectionObserver: whenever the last page is about to come into view, append more.
      // This makes it feel like TikTok: you never hit the end.
      let lastPageObserver = null;

      function resetLastPageObserver() {
        if (lastPageObserver) lastPageObserver.disconnect();

        lastPageObserver = new IntersectionObserver(
          (entries) => {
            for (const entry of entries) {
              if (entry.isIntersecting) {
                ensureAheadBuffer();
              }
            }
          },
          {
            root: pagesContainer,
            threshold: 0.5
          }
        );

        const pages = pagesContainer.querySelectorAll(".page");
        const last = pages[pages.length - 1];
        if (last) lastPageObserver.observe(last);
      }

      // Update current page index continuously, then keep the buffer ahead.
      let scrollTicking = false;
      pagesContainer.addEventListener("scroll", () => {
        if (scrollTicking) return;
        scrollTicking = true;

        requestAnimationFrame(() => {
          const vh = window.innerHeight || 1;
          const idx = Math.round(pagesContainer.scrollTop / vh);
          currentPageIndex = Math.max(0, Math.min(idx, pagesLoaded - 1));

          // Keep ahead buffer as you browse
          ensureAheadBuffer();

          scrollTicking = false;
        });
      });

      // Whenever we append a page, re-observe the new last page
      const originalAddPage = addPage;
      addPage = function (content) {
        const el = originalAddPage(content);
        resetLastPageObserver();
        return el;
      };

      document.getElementById("okButton").addEventListener("click", async (event) => {
        event.stopPropagation();

        if (!apiKey) {
          apiKey = document.getElementById("apiKey").value.trim();
          if (!apiKey) {
            alert("Please enter a valid API key.");
            return;
          }
          localStorage.setItem("openaiApiKey", apiKey);
          document.getElementById("apiKey").classList.add("hidden");
        }

        const subject = document.getElementById("subjectInput").value.trim();
        if (!subject) {
          alert("Please enter a subject.");
          return;
        }

        // Cancel any in-flight requests from a previous run
        for (const c of pendingAbortControllers) {
          try { c.abort(); } catch (_) {}
        }
        pendingAbortControllers.clear();

        // Reset state
        searchTerms = [];
        currentPageIndex = 0;
        pagesLoaded = 0;
        queueInFlight = 0;
        pagesContainer.innerHTML = "";

        document.getElementById("form-container").classList.add("hidden");

        try {
          // First page streams in
          const firstPage = addPage("Loading…");
          const firstSummary = await streamSummaryIntoPage(subject, firstPage);
          const title = firstSummary.split("\n")[0].trim();
          if (title) searchTerms.push(title);

          updatePage(firstPage, firstSummary);

          // Immediately start filling the ahead buffer in the background
          ensureAheadBuffer();
        } catch (err) {
          console.error(err);
          addErrorPage("Failed to generate first page", err);
        }
      });
    </script>
  </body>
</html>