<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="icon" type="image/png" href="rabbit.png" />
    <link rel="apple-touch-icon" href="rabbit.png" />

    <title>RABBIT HOLE</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: black;
        color: white;
      }
      #form-container {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        z-index: 10;
        width: 100%;
        padding: 20px;
        box-sizing: border-box;
      }
      input,
      button {
        padding: 10px;
        font-size: 24px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
      }
      input {
        width: 100%;
      }
      button {
        cursor: pointer;
        background-color: #444;
        color: white;
      }
      .hidden {
        display: none;
      }
      #pages {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        overflow-y: auto;
        scroll-snap-type: y mandatory;
      }
      .page {
        height: 100vh;
        padding: 20px;
        box-sizing: border-box;
        scroll-snap-align: start;
        white-space: pre-wrap;

        font-size: 20px;
        line-height: 1.35;
      }
      .small {
        opacity: 0.75;
        font-size: 14px;
        margin-top: 10px;
      }
    </style>
  </head>

  <body>
    <div id="form-container">
      <input type="password" id="apiKey" placeholder="Enter your OpenAI API key" />
      <input type="text" id="subjectInput" placeholder="Enter a starting subject" />
      <button id="okButton">OK</button>
      <img
        src="rabbit.png"
        alt="Rabbit"
        style="display: block; margin: 20px auto; max-width: 200px"
      />
      <div class="small">Tip: serve from http://localhost while testing (not file://).</div>
    </div>

    <div id="pages"></div>

    <script>
      const OPENAI_RESPONSES_URL = "https://api.openai.com/v1/responses";

      // Models (real, from official docs)
      const MODEL_SUMMARY = "gpt-5.2-chat-latest"; // medium speed
      const MODEL_CHAIN = "gpt-5-nano"; // very fast (swap to "gpt-5-mini" if you want)

      const DEFAULT_REASONING_EFFORT = "medium";
      const DEFAULT_VERBOSITY = "medium";

      // Chain step should be as fast as possible
      const CHAIN_REASONING_EFFORT = "none";
      const CHAIN_VERBOSITY = "low";

      const MAX_WORDS = 100; // keeping your current value

      // Auto-fit settings
      const BASE_FONT_SIZE_PX = 20;
      const MIN_FONT_SIZE_PX = 12;

      // Networking
      const REQUEST_TIMEOUT_MS = 20000;

      let searchTerms = [];
      let apiKey = localStorage.getItem("openaiApiKey") || "";
      if (apiKey) {
        document.getElementById("apiKey").classList.add("hidden");
      }

      let currentPageIndex = 0;
      let pagesLoaded = 0;

      // Tracks whether we are currently generating the next page
      let nextPageInFlight = false;

      function clampToWords(text, maxWords) {
        const tokens = String(text).trim().split(/\s+/).filter(Boolean);
        if (tokens.length <= maxWords) return String(text).trim();
        return tokens.slice(0, maxWords).join(" ").trim() + "…";
      }

      function extractOutputText(data) {
        if (!data) return "";

        // Some clients expose output_text as a convenience, so try it first if present
        if (typeof data.output_text === "string" && data.output_text.trim()) {
          return data.output_text.trim();
        }

        // Standard Responses output parsing
        if (!Array.isArray(data.output)) return "";

        const chunks = [];
        for (const item of data.output) {
          // Newer and older shapes exist, so be liberal:
          // - message items with content parts
          // - sometimes direct output_text items
          if (item && item.type === "message" && Array.isArray(item.content)) {
            for (const part of item.content) {
              if (part && part.type === "output_text" && typeof part.text === "string") {
                chunks.push(part.text);
              }
            }
            continue;
          }

          if (item && item.type === "output_text" && typeof item.text === "string") {
            chunks.push(item.text);
          }
        }

        return chunks.join("\n").trim();
      }

      function isLikelyCorsOrNetworkError(err) {
        const msg = (err && err.message ? err.message : String(err)).toLowerCase();
        return (
          msg.includes("failed to fetch") ||
          msg.includes("networkerror") ||
          msg.includes("cors") ||
          msg.includes("blocked by") ||
          msg.includes("access-control-allow-origin")
        );
      }

      function fetchWithTimeout(url, options, timeoutMs) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeoutMs);
        return fetch(url, { ...options, signal: controller.signal }).finally(() => clearTimeout(id));
      }

      async function openAIResponses({ model, input, instructions, max_output_tokens, reasoningEffort, verbosity }) {
        if (!apiKey) throw new Error("Missing API key.");

        let response;
        let raw = "";

        try {
          response = await fetchWithTimeout(
            OPENAI_RESPONSES_URL,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + apiKey
              },
              body: JSON.stringify({
                model,
                instructions,
                input,
                reasoning: { effort: reasoningEffort },
                text: { verbosity },
                max_output_tokens
              })
            },
            REQUEST_TIMEOUT_MS
          );

          raw = await response.text();
        } catch (err) {
          const extra =
            location.protocol === "file:"
              ? "\n\nYou are running from file://. Serve from http://localhost."
              : "";

          const corsHint = isLikelyCorsOrNetworkError(err)
            ? "\n\nThis looks like a browser CORS or network block. If this is the case, you will need to call OpenAI from a small server proxy rather than directly from the browser."
            : "";

          const timeoutHint =
            err && err.name === "AbortError"
              ? "\n\nRequest timed out. Try a faster model for the chain step (gpt-5-nano) or increase REQUEST_TIMEOUT_MS."
              : "";

          throw new Error(`${err && err.message ? err.message : String(err)}${extra}${corsHint}${timeoutHint}`);
        }

        let data = null;
        try {
          data = JSON.parse(raw);
        } catch (_) {}

        if (!response.ok) {
          const apiMsg =
            data && data.error && data.error.message ? data.error.message : raw || "Unknown error";
          throw new Error(`OpenAI error (${response.status}): ${apiMsg}`);
        }

        if (data && data.status === "failed" && data.error) {
          const apiMsg = data.error.message || JSON.stringify(data.error);
          throw new Error(`OpenAI failed: ${apiMsg}`);
        }

        const text = extractOutputText(data);
        if (!text) {
          const status = data && data.status ? data.status : "unknown";
          throw new Error(
            `No text found in response (status: ${status}).\n\nRaw response keys: ${
              data ? Object.keys(data).join(", ") : "none"
            }`
          );
        }

        return text;
      }

      function addErrorPage(title, err) {
        const msg = err && err.message ? err.message : String(err);
        addPage(`${title}\n\n${msg}`);
      }

      function fitsInPage(el) {
        return el.scrollHeight <= el.clientHeight;
      }

      function fitTextToPage(el) {
        let low = MIN_FONT_SIZE_PX;
        let high = BASE_FONT_SIZE_PX;

        el.style.fontSize = BASE_FONT_SIZE_PX + "px";
        el.style.lineHeight = "1.35";

        if (fitsInPage(el)) return;

        while (high - low > 0.5) {
          const mid = (low + high) / 2;
          el.style.fontSize = mid + "px";
          if (fitsInPage(el)) {
            low = mid;
          } else {
            high = mid;
          }
        }

        el.style.fontSize = Math.max(MIN_FONT_SIZE_PX, Math.floor(low)) + "px";

        if (!fitsInPage(el)) {
          el.style.lineHeight = "1.2";
        }
      }

      function createPageElement(text) {
        const pageDiv = document.createElement("div");
        pageDiv.className = "page";
        pageDiv.innerText = clampToWords(text, MAX_WORDS);
        pageDiv.style.fontSize = BASE_FONT_SIZE_PX + "px";
        pageDiv.style.lineHeight = "1.35";
        return pageDiv;
      }

      function addPage(content) {
        const pagesContainer = document.getElementById("pages");
        const pageDiv = createPageElement(content);
        pagesContainer.appendChild(pageDiv);
        pagesLoaded++;
        requestAnimationFrame(() => fitTextToPage(pageDiv));
        return pageDiv;
      }

      function addLoadingPage() {
        return addPage("Loading…");
      }

      // Refit all pages on resize/orientation change
      window.addEventListener("resize", () => {
        const pages = document.querySelectorAll(".page");
        for (const p of pages) {
          requestAnimationFrame(() => fitTextToPage(p));
        }
      });

      async function getGPTText(term) {
        const prompt =
          `Generate a short, engaging research summary that fills an iPhone screen.\n` +
          `Start with a title that is the search term, then a newline, then a concise summary.\n` +
          `Hard limit: ${MAX_WORDS} words total (including the title).\n` +
          `If you are about to exceed the limit, compress rather than continue.\n` +
          `The search term is: "${term}"`;

        const text = await openAIResponses({
          model: MODEL_SUMMARY,
          instructions: "You are a creative and analytical research assistant.",
          input: [{ role: "user", content: prompt }],
          max_output_tokens: 260,
          reasoningEffort: DEFAULT_REASONING_EFFORT,
          verbosity: DEFAULT_VERBOSITY
        });

        return clampToWords(text, MAX_WORDS);
      }

      async function getChainGPTKeyword() {
        const prompt =
          `Based on the following chain of subjects: ${searchTerms.join(", ")},\n` +
          `Return a single, concise search term that logically moves deeper into the subject.\n` +
          `Not sideways or elaborating on the same subject. Deeper. Logically continuing the chain of subjects.\n` +
          `Your new chosen topic should be so much deeper that it doesn't include words from the previous search term.\n` +
          `If it's more than 6 words, shorten your new chosen topic into 6 words or less.\n` +
          `Return only the search term.`;

        const text = await openAIResponses({
          model: MODEL_CHAIN,
          instructions: "You are a creative and analytical research assistant.",
          input: [{ role: "user", content: prompt }],
          max_output_tokens: 30,
          reasoningEffort: CHAIN_REASONING_EFFORT,
          verbosity: CHAIN_VERBOSITY
        });

        return text.trim().split("\n")[0].trim();
      }

      async function generateIntoPlaceholder(placeholderEl) {
        const newTerm = await getChainGPTKeyword();
        if (!newTerm) throw new Error("No term generated.");

        const content = await getGPTText(newTerm);
        if (!content) throw new Error("No content generated.");

        const title = content.split("\n")[0].trim();
        searchTerms.push(title);

        placeholderEl.innerText = clampToWords(content, MAX_WORDS);
        placeholderEl.style.fontSize = BASE_FONT_SIZE_PX + "px";
        placeholderEl.style.lineHeight = "1.35";
        requestAnimationFrame(() => fitTextToPage(placeholderEl));
      }

      async function ensureNextPageLoaded() {
        // If we already have a request running, do nothing
        if (nextPageInFlight) return;

        // If there is already at least one page ahead of the current page, do nothing
        if (pagesLoaded > currentPageIndex + 1) return;

        nextPageInFlight = true;

        // Create an actual next page immediately so scroll works
        const placeholder = addLoadingPage();

        try {
          await generateIntoPlaceholder(placeholder);
        } catch (err) {
          console.error(err);
          placeholder.innerText = `Failed to load next page\n\n${err && err.message ? err.message : String(err)}`;
          placeholder.style.fontSize = BASE_FONT_SIZE_PX + "px";
          placeholder.style.lineHeight = "1.35";
          requestAnimationFrame(() => fitTextToPage(placeholder));
        } finally {
          nextPageInFlight = false;
        }
      }

      // Scroll behaviour: when user goes halfway into the next page, snap and queue another
      document.getElementById("pages").addEventListener("scroll", () => {
        const pagesContainer = document.getElementById("pages");
        const scrollPosition = pagesContainer.scrollTop;
        const viewportHeight = window.innerHeight;

        if (scrollPosition >= (currentPageIndex + 0.5) * viewportHeight) {
          if (currentPageIndex < pagesLoaded - 1) {
            currentPageIndex++;
            pagesContainer.scrollTo({
              top: currentPageIndex * viewportHeight,
              behavior: "smooth"
            });

            // Ensure there will be yet another page ready (or loading) beyond this one
            ensureNextPageLoaded();
          }
        }
      });

      document.getElementById("okButton").addEventListener("click", async (event) => {
        event.stopPropagation();

        if (!apiKey) {
          apiKey = document.getElementById("apiKey").value.trim();
          if (!apiKey) {
            alert("Please enter a valid API key.");
            return;
          }
          localStorage.setItem("openaiApiKey", apiKey);
          document.getElementById("apiKey").classList.add("hidden");
        }

        const subject = document.getElementById("subjectInput").value.trim();
        if (!subject) {
          alert("Please enter a subject.");
          return;
        }

        document.getElementById("form-container").classList.add("hidden");

        try {
          const content = await getGPTText(subject);
          const title = content.split("\n")[0].trim();
          searchTerms.push(title);
          addPage(content);

          // Immediately create and start loading the next page
          ensureNextPageLoaded();
        } catch (err) {
          console.error(err);
          addErrorPage("Failed to generate first page", err);
        }
      });
    </script>
  </body>
</html>
