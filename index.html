<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Navigator</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: black;
        color: white;
      }
      #form-container {
        position: absolute;
        z-index: 10;
        width: 100%;
        padding: 20px;
      }
      input, button {
        padding: 10px;
        font-size: 16px;
        margin: 5px;
        border: none;
        border-radius: 4px;
      }
      input {
        width: calc(100% - 22px);
      }
      button {
        cursor: pointer;
        background-color: #444;
        color: white;
      }
      .hidden {
        display: none;
      }
      /* The container that holds all pages */
      #pages {
        height: 100vh;
        overflow-y: scroll;
        scroll-snap-type: y mandatory;
      }
      /* Each page takes the full viewport height */
      .page {
        height: 100vh;
        padding: 20px;
        box-sizing: border-box;
        scroll-snap-align: start;
      }
    </style>
  </head>
  <body>
    <div id="form-container">
      <input type="text" id="apiKey" placeholder="Enter your OpenAI API key">
      <input type="text" id="subjectInput" placeholder="Enter a starting subject">
      <button id="okButton">OK</button>
    </div>
    <div id="pages"></div>

    <script>
      let searchTerms = [];
      let apiKey = localStorage.getItem("openaiApiKey") || "";
      if (apiKey) {
        document.getElementById("apiKey").classList.add("hidden");
      }
      let currentPageIndex = 0;
      let preloadedPageContent = null;
      let preloadedPageTitle = null;
      let isPreloading = false;

      // On clicking OK, generate the first page and start preloading the next.
      document.getElementById("okButton").addEventListener("click", async (event) => {
        event.stopPropagation();
        if (!apiKey) {
          apiKey = document.getElementById("apiKey").value.trim();
          if (!apiKey) {
            alert("Please enter a valid API key.");
            return;
          }
          localStorage.setItem("openaiApiKey", apiKey);
        }
        const subject = document.getElementById("subjectInput").value.trim();
        if (!subject) {
          alert("Please enter a subject.");
          return;
        }
        document.getElementById("form-container").classList.add("hidden");
        const pagesContainer = document.getElementById("pages");
        // Generate the first page
        const firstContent = await getGPTText(subject);
        if (firstContent) {
          const firstTitle = firstContent.split("\n")[0].trim();
          searchTerms.push(firstTitle);
          addPage(firstContent);
          // Preload the next page in the background
          preloadNextPage();
        } else {
          addPage("No content generated for: " + subject);
        }
      });

      // Append a new page to the pages container.
      function addPage(content) {
        const pagesContainer = document.getElementById("pages");
        const pageDiv = document.createElement("div");
        pageDiv.className = "page";
        pageDiv.innerText = content;
        pagesContainer.appendChild(pageDiv);
      }

      // Call GPT to generate a research summary based on a term.
      async function getGPTText(term) {
        const prompt = `You are a creative and analytical research assistant.
Generate a short, engaging research summary that fills an iPhone screen.
Start with a title that is the search term, then a newline, then a concise summary.
Keep the response short.
The search term is: "${term}"`;
        try {
          const response = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer " + apiKey
            },
            body: JSON.stringify({
              model: "gpt-4o-mini-2024-07-18",
              messages: [
                { role: "system", content: "You are a creative research assistant." },
                { role: "user", content: prompt }
              ],
              max_tokens: 150,
              temperature: 0.7
            })
          });
          if (!response.ok) throw new Error("OpenAI API request failed");
          const data = await response.json();
          return data.choices[0].message.content.trim();
        } catch (error) {
          console.error("Error fetching GPT text:", error);
          return null;
        }
      }

      // Get a deeper search term based on the current chain.
      async function getChainGPTKeyword() {
        if (!apiKey) return null;
        const prompt = `You are a creative and analytical research assistant.
Based on the following chain of subjects: ${searchTerms.join(", ")},
Return a single, concise search term that logically moves deeper into the subject.
Not sideways or elaborating on the same subject. Deeper. One full step deeper, past the previous search term.
Your new chosen topic should be so much deeper that it doesn't include words from the previous search term.
Return only the search term.`;
        try {
          const response = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer " + apiKey
            },
            body: JSON.stringify({
              model: "gpt-4o-mini-2024-07-18",
              messages: [
                { role: "system", content: "You are a creative research assistant." },
                { role: "user", content: prompt }
              ],
              max_tokens: 10,
              temperature: 0.7
            })
          });
          if (!response.ok) throw new Error("OpenAI API request failed");
          const data = await response.json();
          const newTerm = data.choices[0].message.content.trim();
          console.log("Chain GPT keyword:", newTerm);
          return newTerm;
        } catch (error) {
          console.error("Error fetching chain GPT keyword:", error);
          return null;
        }
      }

      // Preload the next page's content in the background.
      async function preloadNextPage() {
        if (isPreloading) return;
        isPreloading = true;
        const newTerm = await getChainGPTKeyword();
        if (newTerm) {
          const content = await getGPTText(newTerm);
          if (content) {
            preloadedPageContent = content;
            preloadedPageTitle = content.split("\n")[0].trim();
            console.log("Preloaded page ready:", preloadedPageTitle);
          }
        }
        isPreloading = false;
      }

      // Listen for scroll events on the pages container.
      // When the user reaches the next page, if it's preloaded, append it and then start preloading the next page.
      const pagesContainer = document.getElementById("pages");
      pagesContainer.addEventListener("scroll", () => {
        const scrollPosition = pagesContainer.scrollTop;
        const viewportHeight = window.innerHeight;
        // When scrolled to (or very near) the next page...
        if (scrollPosition >= (currentPageIndex + 1) * viewportHeight - 10) {
          if (preloadedPageContent) {
            // Add the preloaded page
            searchTerms.push(preloadedPageTitle);
            currentPageIndex++;
            addPage(preloadedPageContent);
            // Clear preloaded data and preload the next page
            preloadedPageContent = null;
            preloadedPageTitle = null;
            preloadNextPage();
          } else {
            // If no next page is preloaded, snap back to the current page.
            pagesContainer.scrollTo({ top: currentPageIndex * viewportHeight, behavior: "smooth" });
          }
        }
      });
    </script>
  </body>
</html>
