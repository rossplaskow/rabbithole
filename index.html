<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="icon" type="image/png" href="rabbit.png">
    <link rel="apple-touch-icon" href="rabbit.png">

    <title>RABBIT HOLE</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: black;
        color: white;
      }
      #form-container {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        z-index: 10;
        width: 100%;
        padding: 20px;
        box-sizing: border-box;
      }
      input, button {
        padding: 10px;
        font-size: 24px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
      }
      input {
        width: 100%;
      }
      button {
        cursor: pointer;
        background-color: #444;
        color: white;
      }
      .hidden {
        display: none;
      }
      #pages {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        overflow-y: auto;
        scroll-snap-type: y mandatory;
      }
      .page {
        height: 100vh;
        padding: 20px;
        box-sizing: border-box;
        scroll-snap-align: start;
        font-size: 20px;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <div id="form-container">
      <input type="password" id="apiKey" placeholder="Enter your OpenAI API key">
      <input type="text" id="subjectInput" placeholder="Enter a starting subject">
      <button id="okButton">OK</button>
      <img src="rabbit.png" alt="Rabbit" style="display: block; margin: 20px auto; max-width: 200px;">
      <div id="hint" style="opacity: 0.75; font-size: 14px; margin-top: 10px;">
        Tip: if this page is opened as a file, serve it from http://localhost instead.
      </div>
    </div>

    <div id="pages"></div>

    <script>
      const OPENAI_CHAT_COMPLETIONS_URL = "https://api.openai.com/v1/chat/completions";
      const MODEL = "gpt-5.2-chat-latest";

      let searchTerms = [];
      let apiKey = localStorage.getItem("openaiApiKey") || "";
      if (apiKey) {
        document.getElementById("apiKey").classList.add("hidden");
      }

      let currentPageIndex = 0;
      let pagesLoaded = 0;

      function addPage(content) {
        const pagesContainer = document.getElementById("pages");
        const pageDiv = document.createElement("div");
        pageDiv.className = "page";
        pageDiv.innerText = content;
        pagesContainer.appendChild(pageDiv);
        pagesLoaded++;
      }

      function addErrorPage(title, err) {
        const msg = (err && err.message) ? err.message : String(err);
        addPage(`${title}\n\n${msg}`);
      }

      async function openAIChat(messages, { max_completion_tokens, temperature }) {
        if (!apiKey) throw new Error("Missing API key.");

        const response = await fetch(OPENAI_CHAT_COMPLETIONS_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + apiKey
          },
          body: JSON.stringify({
            model: MODEL,
            messages,
            max_completion_tokens,
            temperature
          })
        });

        const raw = await response.text();
        let data = null;
        try {
          data = JSON.parse(raw);
        } catch (_) {
          // Keep data null, raw may be HTML from a proxy, or empty on some failures.
        }

        if (!response.ok) {
          const apiMsg = data && data.error && data.error.message ? data.error.message : raw;
          throw new Error(`OpenAI error (${response.status}): ${apiMsg || "Unknown error"}`);
        }

        const content = data && data.choices && data.choices[0] && data.choices[0].message
          ? data.choices[0].message.content
          : null;

        if (!content) {
          throw new Error("OpenAI returned no message content (unexpected response shape).");
        }

        return content.trim();
      }

      async function getGPTText(term) {
        const prompt =
`You are a creative and analytical research assistant.
Generate a short, engaging research summary that fills an iPhone screen.
Start with a title that is the search term, then a newline, then a concise summary.
Keep the response short.
The search term is: "${term}"`;

        return openAIChat(
          [
            { role: "system", content: "You are a creative research assistant." },
            { role: "user", content: prompt }
          ],
          { max_completion_tokens: 150, temperature: 1 }
        );
      }

      async function getChainGPTKeyword() {
        const prompt =
`You are a creative and analytical research assistant.
Based on the following chain of subjects: ${searchTerms.join(", ")},
Return a single, concise search term that logically moves deeper into the subject.
Not sideways or elaborating on the same subject. Deeper. Logically continuing the chain of subjects.
Your new chosen topic should be so much deeper that it doesn't include words from the previous search term.
If it's more than 6 words, shorten your new chosen topic into 6 words or less.
Return only the search term.`;

        const text = await openAIChat(
          [
            { role: "system", content: "You are a creative research assistant." },
            { role: "user", content: prompt }
          ],
          { max_completion_tokens: 10, temperature: 1 }
        );

        return text.trim();
      }

      async function preloadNextPage() {
        if (pagesLoaded !== currentPageIndex + 1) return;

        try {
          const newTerm = await getChainGPTKeyword();
          if (!newTerm) return;

          const content = await getGPTText(newTerm);
          if (!content) return;

          const title = content.split("\n")[0].trim();
          searchTerms.push(title);
          addPage(content);
        } catch (err) {
          console.error(err);
          addErrorPage("Failed to load next page", err);
        }
      }

      document.getElementById("pages").addEventListener("scroll", () => {
        const pagesContainer = document.getElementById("pages");
        const scrollPosition = pagesContainer.scrollTop;
        const viewportHeight = window.innerHeight;

        if (scrollPosition >= (currentPageIndex + 0.5) * viewportHeight) {
          if (currentPageIndex < pagesLoaded - 1) {
            currentPageIndex++;
            pagesContainer.scrollTo({ top: currentPageIndex * viewportHeight, behavior: "smooth" });
            preloadNextPage();
          }
        }
      });

      document.getElementById("okButton").addEventListener("click", async (event) => {
        event.stopPropagation();

        if (!apiKey) {
          apiKey = document.getElementById("apiKey").value.trim();
          if (!apiKey) {
            alert("Please enter a valid API key.");
            return;
          }
          localStorage.setItem("openaiApiKey", apiKey);
        }

        const subject = document.getElementById("subjectInput").value.trim();
        if (!subject) {
          alert("Please enter a subject.");
          return;
        }

        document.getElementById("form-container").classList.add("hidden");

        try {
          const content = await getGPTText(subject);
          const title = content.split("\n")[0].trim();
          searchTerms.push(title);
          addPage(content);
          preloadNextPage();
        } catch (err) {
          console.error(err);
          addErrorPage("Failed to generate first page", err);
        }
      });
    </script>
  </body>
</html>
